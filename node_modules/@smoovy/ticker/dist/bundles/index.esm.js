class t{constructor(t){this.calllback=t,this.dead=!1}update(t,i){this.calllback(t,i,this.kill.bind(this))}kill(){this.dead=!0}}class i{constructor(t){this.intervalMs=.06,this.ticking=!1,this.override=!1,this.threads=[],this.lastTime=-1,this.minDeltaMs=0,this.maxDeltaMs=100,t instanceof Array&&2===t.length&&(this.setMinFPS(t[0]),this.setMaxFPS(t[1])),"number"==typeof t&&this.setMaxFPS(t)}static requestAnimationFrame(t){return window.requestAnimationFrame?window.requestAnimationFrame(t):window.setTimeout(t,1e3/60)}static now(){return(window.performance||Date).now()}setMinFPS(t){const i=Math.max(Math.min(t,this.maxFPS),0);return this.maxDeltaMs=1/Math.min(i/1e3,this.intervalMs)}get minFPS(){return 1e3/this.maxDeltaMs}setMaxFPS(t){if(0===t)return this.minDeltaMs=0;const i=Math.max(t,this.minFPS);return this.minDeltaMs=1/(i/1e3)}get maxFPS(){return this.minDeltaMs>0?1e3/this.minDeltaMs:1e3*this.intervalMs}tick(t,s=i.now()){const e=[];for(let i=0,a=this.threads.length;i<a;i++){const a=this.threads[i];a.dead?e.push(a):a.update(t,s)}for(let t=0,i=e.length;t<i;t++)this.buryThread(e[t])}update(t=i.now()){if(t>this.lastTime){let i=t-this.lastTime;if(i>this.maxDeltaMs&&(i=this.maxDeltaMs),this.minDeltaMs&&i+1<this.minDeltaMs)return;this.tick(i*this.intervalMs,t)}this.lastTime=t}animate(){i.requestAnimationFrame(t=>{this.update(t),this.ticking&&!this.override&&this.threads.length>0?this.animate():this.ticking=!1})}kill(){this.threads.forEach(t=>t.kill())}buryThread(t){this.threads.splice(this.threads.indexOf(t),1)}add(s){const e=new t(s);return this.threads.push(e),this.ticking||this.override||(this.lastTime=i.now(),this.ticking=!0,this.animate()),e}}export{i as Ticker,t as TickerThread};
//# sourceMappingURL=index.esm.js.map
